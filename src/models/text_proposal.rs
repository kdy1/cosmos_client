/* 
 * Gaia-Lite for Cosmos
 *
 * A REST interface for state queries, transaction generation and broadcasting.
 *
 * OpenAPI spec version: 3.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct TextProposal {
  #[serde(rename = "proposal_id")]
  proposal_id: Option<i32>,
  #[serde(rename = "title")]
  title: Option<String>,
  #[serde(rename = "description")]
  description: Option<String>,
  #[serde(rename = "proposal_type")]
  proposal_type: Option<String>,
  #[serde(rename = "proposal_status")]
  proposal_status: Option<String>,
  #[serde(rename = "final_tally_result")]
  final_tally_result: Option<::models::TallyResult>,
  #[serde(rename = "submit_time")]
  submit_time: Option<String>,
  #[serde(rename = "total_deposit")]
  total_deposit: Option<Vec<::models::Coin>>,
  #[serde(rename = "voting_start_time")]
  voting_start_time: Option<String>
}

impl TextProposal {
  pub fn new() -> TextProposal {
    TextProposal {
      proposal_id: None,
      title: None,
      description: None,
      proposal_type: None,
      proposal_status: None,
      final_tally_result: None,
      submit_time: None,
      total_deposit: None,
      voting_start_time: None
    }
  }

  pub fn set_proposal_id(&mut self, proposal_id: i32) {
    self.proposal_id = Some(proposal_id);
  }

  pub fn with_proposal_id(mut self, proposal_id: i32) -> TextProposal {
    self.proposal_id = Some(proposal_id);
    self
  }

  pub fn proposal_id(&self) -> Option<&i32> {
    self.proposal_id.as_ref()
  }

  pub fn reset_proposal_id(&mut self) {
    self.proposal_id = None;
  }

  pub fn set_title(&mut self, title: String) {
    self.title = Some(title);
  }

  pub fn with_title(mut self, title: String) -> TextProposal {
    self.title = Some(title);
    self
  }

  pub fn title(&self) -> Option<&String> {
    self.title.as_ref()
  }

  pub fn reset_title(&mut self) {
    self.title = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> TextProposal {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_proposal_type(&mut self, proposal_type: String) {
    self.proposal_type = Some(proposal_type);
  }

  pub fn with_proposal_type(mut self, proposal_type: String) -> TextProposal {
    self.proposal_type = Some(proposal_type);
    self
  }

  pub fn proposal_type(&self) -> Option<&String> {
    self.proposal_type.as_ref()
  }

  pub fn reset_proposal_type(&mut self) {
    self.proposal_type = None;
  }

  pub fn set_proposal_status(&mut self, proposal_status: String) {
    self.proposal_status = Some(proposal_status);
  }

  pub fn with_proposal_status(mut self, proposal_status: String) -> TextProposal {
    self.proposal_status = Some(proposal_status);
    self
  }

  pub fn proposal_status(&self) -> Option<&String> {
    self.proposal_status.as_ref()
  }

  pub fn reset_proposal_status(&mut self) {
    self.proposal_status = None;
  }

  pub fn set_final_tally_result(&mut self, final_tally_result: ::models::TallyResult) {
    self.final_tally_result = Some(final_tally_result);
  }

  pub fn with_final_tally_result(mut self, final_tally_result: ::models::TallyResult) -> TextProposal {
    self.final_tally_result = Some(final_tally_result);
    self
  }

  pub fn final_tally_result(&self) -> Option<&::models::TallyResult> {
    self.final_tally_result.as_ref()
  }

  pub fn reset_final_tally_result(&mut self) {
    self.final_tally_result = None;
  }

  pub fn set_submit_time(&mut self, submit_time: String) {
    self.submit_time = Some(submit_time);
  }

  pub fn with_submit_time(mut self, submit_time: String) -> TextProposal {
    self.submit_time = Some(submit_time);
    self
  }

  pub fn submit_time(&self) -> Option<&String> {
    self.submit_time.as_ref()
  }

  pub fn reset_submit_time(&mut self) {
    self.submit_time = None;
  }

  pub fn set_total_deposit(&mut self, total_deposit: Vec<::models::Coin>) {
    self.total_deposit = Some(total_deposit);
  }

  pub fn with_total_deposit(mut self, total_deposit: Vec<::models::Coin>) -> TextProposal {
    self.total_deposit = Some(total_deposit);
    self
  }

  pub fn total_deposit(&self) -> Option<&Vec<::models::Coin>> {
    self.total_deposit.as_ref()
  }

  pub fn reset_total_deposit(&mut self) {
    self.total_deposit = None;
  }

  pub fn set_voting_start_time(&mut self, voting_start_time: String) {
    self.voting_start_time = Some(voting_start_time);
  }

  pub fn with_voting_start_time(mut self, voting_start_time: String) -> TextProposal {
    self.voting_start_time = Some(voting_start_time);
    self
  }

  pub fn voting_start_time(&self) -> Option<&String> {
    self.voting_start_time.as_ref()
  }

  pub fn reset_voting_start_time(&mut self) {
    self.voting_start_time = None;
  }

}



