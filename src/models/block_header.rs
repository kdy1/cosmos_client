/* 
 * Gaia-Lite for Cosmos
 *
 * A REST interface for state queries, transaction generation and broadcasting.
 *
 * OpenAPI spec version: 3.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct BlockHeader {
  #[serde(rename = "chain_id")]
  chain_id: Option<String>,
  #[serde(rename = "height")]
  height: Option<f32>,
  #[serde(rename = "time")]
  time: Option<String>,
  #[serde(rename = "num_txs")]
  num_txs: Option<f32>,
  #[serde(rename = "last_block_id")]
  last_block_id: Option<::models::BlockId>,
  #[serde(rename = "total_txs")]
  total_txs: Option<f32>,
  #[serde(rename = "last_commit_hash")]
  last_commit_hash: Option<::models::Hash>,
  #[serde(rename = "data_hash")]
  data_hash: Option<::models::Hash>,
  #[serde(rename = "validators_hash")]
  validators_hash: Option<::models::Hash>,
  #[serde(rename = "next_validators_hash")]
  next_validators_hash: Option<::models::Hash>,
  #[serde(rename = "consensus_hash")]
  consensus_hash: Option<::models::Hash>,
  #[serde(rename = "app_hash")]
  app_hash: Option<::models::Hash>,
  #[serde(rename = "last_results_hash")]
  last_results_hash: Option<::models::Hash>,
  #[serde(rename = "evidence_hash")]
  evidence_hash: Option<::models::Hash>,
  #[serde(rename = "proposer_address")]
  proposer_address: Option<::models::Address>,
  #[serde(rename = "version")]
  version: Option<::models::BlockHeaderVersion>
}

impl BlockHeader {
  pub fn new() -> BlockHeader {
    BlockHeader {
      chain_id: None,
      height: None,
      time: None,
      num_txs: None,
      last_block_id: None,
      total_txs: None,
      last_commit_hash: None,
      data_hash: None,
      validators_hash: None,
      next_validators_hash: None,
      consensus_hash: None,
      app_hash: None,
      last_results_hash: None,
      evidence_hash: None,
      proposer_address: None,
      version: None
    }
  }

  pub fn set_chain_id(&mut self, chain_id: String) {
    self.chain_id = Some(chain_id);
  }

  pub fn with_chain_id(mut self, chain_id: String) -> BlockHeader {
    self.chain_id = Some(chain_id);
    self
  }

  pub fn chain_id(&self) -> Option<&String> {
    self.chain_id.as_ref()
  }

  pub fn reset_chain_id(&mut self) {
    self.chain_id = None;
  }

  pub fn set_height(&mut self, height: f32) {
    self.height = Some(height);
  }

  pub fn with_height(mut self, height: f32) -> BlockHeader {
    self.height = Some(height);
    self
  }

  pub fn height(&self) -> Option<&f32> {
    self.height.as_ref()
  }

  pub fn reset_height(&mut self) {
    self.height = None;
  }

  pub fn set_time(&mut self, time: String) {
    self.time = Some(time);
  }

  pub fn with_time(mut self, time: String) -> BlockHeader {
    self.time = Some(time);
    self
  }

  pub fn time(&self) -> Option<&String> {
    self.time.as_ref()
  }

  pub fn reset_time(&mut self) {
    self.time = None;
  }

  pub fn set_num_txs(&mut self, num_txs: f32) {
    self.num_txs = Some(num_txs);
  }

  pub fn with_num_txs(mut self, num_txs: f32) -> BlockHeader {
    self.num_txs = Some(num_txs);
    self
  }

  pub fn num_txs(&self) -> Option<&f32> {
    self.num_txs.as_ref()
  }

  pub fn reset_num_txs(&mut self) {
    self.num_txs = None;
  }

  pub fn set_last_block_id(&mut self, last_block_id: ::models::BlockId) {
    self.last_block_id = Some(last_block_id);
  }

  pub fn with_last_block_id(mut self, last_block_id: ::models::BlockId) -> BlockHeader {
    self.last_block_id = Some(last_block_id);
    self
  }

  pub fn last_block_id(&self) -> Option<&::models::BlockId> {
    self.last_block_id.as_ref()
  }

  pub fn reset_last_block_id(&mut self) {
    self.last_block_id = None;
  }

  pub fn set_total_txs(&mut self, total_txs: f32) {
    self.total_txs = Some(total_txs);
  }

  pub fn with_total_txs(mut self, total_txs: f32) -> BlockHeader {
    self.total_txs = Some(total_txs);
    self
  }

  pub fn total_txs(&self) -> Option<&f32> {
    self.total_txs.as_ref()
  }

  pub fn reset_total_txs(&mut self) {
    self.total_txs = None;
  }

  pub fn set_last_commit_hash(&mut self, last_commit_hash: ::models::Hash) {
    self.last_commit_hash = Some(last_commit_hash);
  }

  pub fn with_last_commit_hash(mut self, last_commit_hash: ::models::Hash) -> BlockHeader {
    self.last_commit_hash = Some(last_commit_hash);
    self
  }

  pub fn last_commit_hash(&self) -> Option<&::models::Hash> {
    self.last_commit_hash.as_ref()
  }

  pub fn reset_last_commit_hash(&mut self) {
    self.last_commit_hash = None;
  }

  pub fn set_data_hash(&mut self, data_hash: ::models::Hash) {
    self.data_hash = Some(data_hash);
  }

  pub fn with_data_hash(mut self, data_hash: ::models::Hash) -> BlockHeader {
    self.data_hash = Some(data_hash);
    self
  }

  pub fn data_hash(&self) -> Option<&::models::Hash> {
    self.data_hash.as_ref()
  }

  pub fn reset_data_hash(&mut self) {
    self.data_hash = None;
  }

  pub fn set_validators_hash(&mut self, validators_hash: ::models::Hash) {
    self.validators_hash = Some(validators_hash);
  }

  pub fn with_validators_hash(mut self, validators_hash: ::models::Hash) -> BlockHeader {
    self.validators_hash = Some(validators_hash);
    self
  }

  pub fn validators_hash(&self) -> Option<&::models::Hash> {
    self.validators_hash.as_ref()
  }

  pub fn reset_validators_hash(&mut self) {
    self.validators_hash = None;
  }

  pub fn set_next_validators_hash(&mut self, next_validators_hash: ::models::Hash) {
    self.next_validators_hash = Some(next_validators_hash);
  }

  pub fn with_next_validators_hash(mut self, next_validators_hash: ::models::Hash) -> BlockHeader {
    self.next_validators_hash = Some(next_validators_hash);
    self
  }

  pub fn next_validators_hash(&self) -> Option<&::models::Hash> {
    self.next_validators_hash.as_ref()
  }

  pub fn reset_next_validators_hash(&mut self) {
    self.next_validators_hash = None;
  }

  pub fn set_consensus_hash(&mut self, consensus_hash: ::models::Hash) {
    self.consensus_hash = Some(consensus_hash);
  }

  pub fn with_consensus_hash(mut self, consensus_hash: ::models::Hash) -> BlockHeader {
    self.consensus_hash = Some(consensus_hash);
    self
  }

  pub fn consensus_hash(&self) -> Option<&::models::Hash> {
    self.consensus_hash.as_ref()
  }

  pub fn reset_consensus_hash(&mut self) {
    self.consensus_hash = None;
  }

  pub fn set_app_hash(&mut self, app_hash: ::models::Hash) {
    self.app_hash = Some(app_hash);
  }

  pub fn with_app_hash(mut self, app_hash: ::models::Hash) -> BlockHeader {
    self.app_hash = Some(app_hash);
    self
  }

  pub fn app_hash(&self) -> Option<&::models::Hash> {
    self.app_hash.as_ref()
  }

  pub fn reset_app_hash(&mut self) {
    self.app_hash = None;
  }

  pub fn set_last_results_hash(&mut self, last_results_hash: ::models::Hash) {
    self.last_results_hash = Some(last_results_hash);
  }

  pub fn with_last_results_hash(mut self, last_results_hash: ::models::Hash) -> BlockHeader {
    self.last_results_hash = Some(last_results_hash);
    self
  }

  pub fn last_results_hash(&self) -> Option<&::models::Hash> {
    self.last_results_hash.as_ref()
  }

  pub fn reset_last_results_hash(&mut self) {
    self.last_results_hash = None;
  }

  pub fn set_evidence_hash(&mut self, evidence_hash: ::models::Hash) {
    self.evidence_hash = Some(evidence_hash);
  }

  pub fn with_evidence_hash(mut self, evidence_hash: ::models::Hash) -> BlockHeader {
    self.evidence_hash = Some(evidence_hash);
    self
  }

  pub fn evidence_hash(&self) -> Option<&::models::Hash> {
    self.evidence_hash.as_ref()
  }

  pub fn reset_evidence_hash(&mut self) {
    self.evidence_hash = None;
  }

  pub fn set_proposer_address(&mut self, proposer_address: ::models::Address) {
    self.proposer_address = Some(proposer_address);
  }

  pub fn with_proposer_address(mut self, proposer_address: ::models::Address) -> BlockHeader {
    self.proposer_address = Some(proposer_address);
    self
  }

  pub fn proposer_address(&self) -> Option<&::models::Address> {
    self.proposer_address.as_ref()
  }

  pub fn reset_proposer_address(&mut self) {
    self.proposer_address = None;
  }

  pub fn set_version(&mut self, version: ::models::BlockHeaderVersion) {
    self.version = Some(version);
  }

  pub fn with_version(mut self, version: ::models::BlockHeaderVersion) -> BlockHeader {
    self.version = Some(version);
    self
  }

  pub fn version(&self) -> Option<&::models::BlockHeaderVersion> {
    self.version.as_ref()
  }

  pub fn reset_version(&mut self) {
    self.version = None;
  }

}



